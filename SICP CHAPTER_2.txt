/**
2.6 Church Numerals
**/
2.1
(define (make-rat n d)
	(let ((g (gcd n d)))
	(cons (/ (if (> (* n d) 0) (abs n) n) g) (/ (abs d) g)))
)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.2
(define make-point cons)
(define x-point car)
(define y-point cdr)
(define make-segment cons)
(define start-segment car)
(define end-segment cdr)
(define (avg a b) (/ (+ a b) 2))
(define (midpoint segment) 
	(make-point
		(avg (x-point (start-segment segment)) (x-point (end-segment segment)))
		(avg (y-point (start-segment segment)) (y-point (end-segment segment))))
)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.3
(define (make-rect point width height) (cons point (cons width height)))
(define (perim rect) 
	(let ((dim (cdr rect))) 
		(* 2 (+  (car dim) (cdr dim))) ))
(define (area rect) 
	(let  ( (dim (cdr rect))) (*  (car dim) (cdr dim))))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.4
(define (cons x y)
(lambda (m) (m x y)))
(define (car z)
(z (lambda (p q) p)))
(define (cdr z)
(z (lambda (p q) q)))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.5
Since 2 and 3 are both prime there's a one to one mapping between all pairs (a,b) and 
integers generated by the formula 2^a3^b.
(define (cons a b) (* (expt 2 a ) (expt 3 b) ))
(define (car x)(car-iter x 0))
(define (car-iter x n) ( if (= 0 (remainder x 2))  (car-iter (/ x 2) (+ n 1)) n)) 
(define (cdr x)(cdr-iter x 0))
(define (cdr-iter x n) ( if (= 0 (remainder x 3))  (car-iter (/ x 3) (+ n 1)) n)) 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.6
(define zero (lambda (f) (lambda (x) x)))
(define one  (lambda (f) (lambda (x) (f x)))))
(define two  (lambda (f) (lambda (x) (f (f x)))))
The addition procedure is applying a function f an additional time.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.7
(define upper-bound car)
(define lower-bound cdr)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.8
(define (add-interval x y)
(make-interval (- (upper-bound x) (lower-bound y))
	       (- (lower-bound x) (upper-bound y))))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.10
(define (spans-zero x) (and (<= (lower-bound x) 0) (>= (upper-bound x) 0))
(define (div-interval x y) 
	(if (spans-zero x) (error "Interval that Spans zero" y)
	(mul-interval x
	(make-interval (/ 1.0 (upper-bound y))
		       (/ 1.0 (lower-bound y))))))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.11
(define (make-interval a b) (cons a b))
(define (pos? x) (> (lower-bound x) 0))
(define (neg? x) (< (upper-bound x) 0))
(define upper-bound cdr)
(define lower-bound car)
(define (old-mul-interval x y) 
   (let ((p1 (* (lower-bound x) (lower-bound y))) 
         (p2 (* (lower-bound x) (upper-bound y))) 
         (p3 (* (upper-bound x) (lower-bound y))) 
         (p4 (* (upper-bound x) (upper-bound y)))) 
     (make-interval (min p1 p2 p3 p4) 
                    (max p1 p2 p3 p4)))) 
  
(define (mul-interval x y)
	(let (  (x1 (lower-bound x)) 
         	(x2 (upper-bound x)) 
         	(y1 (lower-bound y)) 
         	(y2 (upper-bound y))  )
	(cond 
		((pos? x)
			(cond 
				((pos? y) (make-interval (* x1 y1) (* x2 y2)))
				((neg? y) (make-interval (* x2 y1) (* x1 y2)))
				(else	    (make-interval (* x2 y1) (* x2 y2)))
			)
		)
		((neg? x)
			(cond 
				((pos? y) (make-interval (* x1 y2) (* x2 y1)))
				((neg? y) (make-interval (* x2 y2) (* x1 y1)))
				(else	    (make-interval (* x1 y2) (* x1 y1)))
			)
		)
		(else
			(cond 
				((pos? y) (make-interval (* x1 y2) (* x2 y2)))
				((neg? y) (make-interval (* x2 y1) (* x1 y1)))
				(else	
					(let (  (i1 (* x1 y1)) 
                  				(i2 (* x1 y2)) 
                  				(i3 (* x2 y1)) 
                		  		(i4 (* x2 y2)) ) 
              				     (make-interval (min i1 i2 i3 i4)  (max i1 i2 i3 i4))))
			)
		)
	)
	)
)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.12
(define (make-center-percent center tolerance)
	(let ((p (/ tolerance 100)))
	(make-interval (- center (* center p)) (+ center (* center p)))))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.17
(define (last-pair lst) (if (null? (cdr lst)) (car lst) (last-pair (cdr lst)))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.18
(define (reverse-iter lsog lsnw)
	(if (null? lsog) 
	    lsnw 
	    (reverse-iter (cdr lsog) (cons (car lsog) lsnw))))
(define (reverse ls)
	(reverse-iter ls (list) ))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
(define (sum-list s ls) 
	(if (null? ls) 
	    s 
	    (sum-list (+ s (car ls)) (cdr ls))
	)
)
(define (sum x . z) 
	(sum-list x z)
)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.19
(define (filter fun lsog lsnw)
	( if (null? lsog)
	  lsnw
	  (if (fun (car lsog))
		(filter fun (cdr lsog) (cons (car lsog) lsnw))
		(filter fun (cdr lsog) lsnw)
	  )
	)
)
(define (same-parity x . z)
	(let (
		(chk (if (even? x) even? odd?))	
	     )
	     (cons x (filter chk z (list))))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.21
(define (square-list items)
(if (null? items)
nil
(cons (square (car items)) (square-list (cdr items)))))
(define (square-list items)
(map square items))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.23
(define (for-each f ls)
	(let 
		((a (if (null? ls) ls (f (car ls)))))
		(if(null? ls) #t (for-each f (cdr ls)))
	)
))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	
2.25
(car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9))))))
(car (car (list (list 7))))
(car (cdr (car (cdr (car (cdr ( car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))))))))))))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.26
(define x (list 1 2 3))
(define y (list 4 5 6))
(append x y) --> (1 2 3 4 5 6)
(cons x y)   --> ((1 2 3) 4 5 6)
(list x y)   --> ((1 2 3) (4 5 6))
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2.27
(define (deep-reverse x)
	(cond 
		((null? x) x)
		((not (list? x)) x)
		(else (reverse (map deep-reverse x)))
	)
)
//Another More readable solution
(define (deep-reverse x) 
   (if (list? x) 
       (reverse (map deep-reverse x)) 
       x)) 


